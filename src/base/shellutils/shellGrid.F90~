module shellGrid
    ! Data type for holding 2D spherical shell grid
    type ShellGrid_T
        integer :: Np,Nt ! Number of lon/lat cells (phi/theta)
        ! xxc = centers (Nx)
        ! xx  = corners (Nx+1)
        ! th (theta) runs from north pole toward south
        ! Assuming lat \in -pi/2,pi/2 and lon \in [0,2pi]
        ! note, th/ph are colatitude/longitude; also, defining lat/latc for latitude
        real(rp), dimension(:), allocatable :: th, ph, thc, phc, lat, latc  !Radians
        logical :: doSP = .false., doNP = .false. !Whether grid contains south/north pole
        real(rp) :: minTheta, maxTheta, minPhi, maxPhi

        ! Local indices, active region
        integer :: is=1,ie,js=1,je
        ! Local indices, including ghosts
        integer :: isg,ieg,jsg,jeg

        ! Ghosts for north, south, east, and west boundaries. East=>larger phi. West => smaller phi.
        ! default to 0
        integer :: Ngn=0, Ngs=0, Nge=0, Ngw=0
    end type ShellGrid_T

    contains

    ! Create a shell grid data structure
    ! Takes Theta and Phi 1D arrays (uniform or not)
    subroutine GenShellGrid(shGr,Theta,Phi)
        type(ShellGrid_T), intent(inout) :: shGr
        real(rp), dimension(:), intent(in) :: Theta, Phi

        integer :: Np, Nt

        ! do some checks first
        if (.not.(isAscending(Theta))) then 
           write(*,*) "Inside shell grid generator (GenShellGrid)."
           write(*,*) "Theta array must be ascending. Quitting..."
           stop
        end if

        if (.not.(isAscending(Phi))) then 
           write(*,*) "Inside shell grid generator (GenShellGrid)."
           write(*,*) "Phi array must be ascending. Quitting..."
           stop
        end if

        if (any(Theta<0.).or.(any(Theta>PI/2))) then
           write(*,*) "Inside shell grid generator (GenShellGrid)."
           write(*,*) "Theta array should be in the range [0,PI/2]. Quitting..."
           stop
        end if

        if (any(Phi<0.).or.(any(Phi>2*PI))) then
           write(*,*) "Inside shell grid generator (GenShellGrid)."
           write(*,*) "Phi array should be in the range [0,2*PI]. Quitting..."
           stop
        end if

        ! define various array indices
        is = 1

        ! Nuke arrays if already allocated
        if (allocated(shGr%th))   deallocate(shGr%th)
        if (allocated(shGr%ph))   deallocate(shGr%ph)
        if (allocated(shGr%thc))  deallocate(shGr%thc)
        if (allocated(shGr%phc))  deallocate(shGr%phc)
        if (allocated(shGr%lat))  deallocate(shGr%lat)
        if (allocated(shGr%latc)) deallocate(shGr%latc)

        ! Create new arrays
        shGr%Np = size(Phi)-1
        shGr%Nt = size(Theta)-1

        allocate(shGr%th(shGr%Nt+1 + Ngn + Ngs))
        allocate(shGr%ph(shGr%Np+1))

        ! allocate(shGr%LatC(shGr%NLat))
        ! allocate(shGr%LonC(shGr%NLon))

        ! !Set edges
        ! shGr%LatI(:) = iLats
        ! dphi = 2*PI/shGr%NLon
        ! do n=1,shGr%NLon+1
        !     shGr%LonI(n) = (n-1)*dphi
        ! enddo

        ! !Set centers
        ! shGr%LatC = ( shGr%LatI(2:shGr%NLat+1) + shGr%LatI(1:shGr%NLat) )/2.0
        ! shGr%LonC = ( shGr%LonI(2:shGr%NLon+1) + shGr%LonI(1:shGr%NLon) )/2.0

        ! !Decide if this has north/south pole
        ! shGr%doNP = .false.
        ! shGr%doSP = .false.
        ! if ( maxval(shGr%LatI) >= (PI/2.0 - TINY) ) then
        !     shGr%doNP = .true.
        ! endif

        ! if ( minval(shGr%LatI) <= (-PI/2.0 + TINY) ) then
        !     shGr%doSP = .true.
        ! endif

        ! if (shGr%doSP .or. shGr%doNP) then
        !     !Die for now
        !     write(*,*) "This routine does not yet support handling north/south pole"
        !     stop
        ! endif
        
        ! shGr%minLat = minval(shGr%LatI)
        ! shGr%maxLat = maxval(shGr%LatI)

    end subroutine GenShellGrid
