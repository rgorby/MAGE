module testVMpi
  use pFUnit
  use gamapp_mpi
  use voltapp_mpi
  use gam2voltcomm_mpi
  use uservoltic

  implicit none

  logical :: isGamera = .false.
  type(gamAppMpi_T), allocatable :: gamAppMpi
  type(voltAppMpi_T), allocatable :: voltAppMpi
  type(gam2voltCommMpi_T), allocatable :: g2vCommMpi

contains

  @before
  subroutine setup(this)
      class (MpiTestMethod), intent(inout) :: this
      character(len=strLen) :: caseFile

      integer :: ierror, gamComm = MPI_COMM_NULL

      call setMpiReal()

      write(caseFile,'(A,I0,A)') 'cmiD_', this%getNumProcesses()-1, '.xml'


      if(this%getProcessRank() < (this%getNumProcesses()-1)) then
          isGamera = .true.
          allocate(gamAppMpi)
          allocate(g2vCommMpi)

          ! make gamera-only mpi communicator
          call MPI_Comm_Split(this%getMpiCommunicator(), 0, this%getProcessRank(), gamComm, ierror)

          call initGamera_mpi(gamAppMpi, initUser, gamComm, caseFile, .false.)
          call initGam2Volt(g2vCommMpi, gamAppMpi, this%getMpiCommunicator())
      else
          isGamera = .false.
          allocate(voltAppMpi)

          ! make gamera-only mpi communicator
          call MPI_Comm_Split(this%getMpiCommunicator(), MPI_UNDEFINED, this%getProcessRank(), gamComm, ierror)

          call initVoltron_mpi(voltAppMpi, initUser, this%getMpiCommunicator(), caseFile)
      endif

  end subroutine setup

  @after
  subroutine teardown(this)
      class (MpiTestMethod), intent(inout) :: this

      if(allocated(gamAppMpi)) deallocate(gamAppMpi)
      if(allocated(voltAppMpi)) deallocate(voltAppMpi)
      if(allocated(g2vCommMpi)) deallocate(g2vCommMpi)

  end subroutine teardown

  !@test(npes=[2,5,17])
  subroutine testStepUpdate(this)
      class (MpiTestMethod), intent(inout) :: this

      character(len=strLen) :: checkMessage

      if(isGamera) then
          ! setting fixed values to gamera to ensure updates occur
          gamAppMpi%Model%t = 1.23
          gamAppMpi%Model%ts = 178
          g2vCommMpi%time = 0
          g2vCommMpi%MJD = 0
          g2vCommMpi%ts = 0

          call performStepVoltron(g2vCommMpi,gamAppMpi)

          write (checkMessage,'(A,I0)') 'voltron time wrong on gamera rank ',this%getProcessRank()
          @assertEqual(1.23*gamAppMpi%Model%Units%gT0, g2vCommMpi%time, trim(checkMessage))
          write (checkMessage,'(A,I0)') 'MJD wrong on gamera rank ',this%getProcessRank()
          @assertEqual(gamAppMpi%Model%MJD0 + g2vCommMpi%time/(60.0*60.0*24.0), g2vCommMpi%MJD, trim(checkMessage))
          write (checkMessage,'(A,I0)') 'voltron ts wrong on gamera rank ',this%getProcessRank()
          @assertEqual(178, g2vCommMpi%ts, trim(checkMessage))
      else
          ! setting fixed values to voltron to ensure updates occur
          voltAppMpi%gAppLocal%Model%t = 0
          voltAppMpi%gAppLocal%Model%ts = 0
          voltAppMpi%time = 0
          voltAppMpi%MJD = 0
          voltAppMpi%ts = 0

          call stepVoltron_mpi(voltAppMpi)

          @assertEqual(1.23, voltAppMpi%gAppLocal%Model%t, 'gamera time value wrong on voltron')
          @assertEqual(178, voltAppMpi%gAppLocal%Model%ts, 'gamera ts value wrong on voltron')
          @assertEqual(1.23*voltAppMpi%gAppLocal%Model%Units%gT0, voltAppMpi%time, 'voltron time value wrong on voltron')
          @assertEqual(voltAppMpi%gAppLocal%Model%MJD0 + voltAppMpi%time/(60.0*60.0*24.0), voltAppMpi%MJD, 'MJD value wrong on voltron')
          @assertEqual(178, voltAppMpi%ts, 'voltron ts value wrong on voltron')
      endif

  end subroutine testStepUpdate

  !@test(npes=[2])
  subroutine testDTypesGasShallow(this)
      class (MpiTestMethod), intent(inout) :: this

      integer :: dataSize,ierr
      integer(MPI_ADDRESS_KIND) :: lb,extent

      call mpi_type_extent(MPI_MYFLOAT, dataSize, ierr) ! number of bytes per array entry

      SELECT CASE(this%getNumProcesses())
          CASE(2)
              if(isGamera) then
                  @assertTrue(MPI_COMM_NULL /= g2vCommMpi%voltMpiComm, '2 processes g2v MPI Comm wrong')
                  @assertEqual((/1/),g2vCommMpi%sendCountsGasShallow, '2 processes g2v countsGasShallow wrong')
                  @assertEqual((/0/),g2vCommMpi%sendDisplsGasShallow, '2 processes g2v displsGasShallow wrong')

                  call mpi_type_get_extent(g2vCommMpi%sendTypesGasShallow(1),lb,extent,ierr)
                  @assertEqual(MPI_SUCCESS, ierr, '2 processes send gas shallow get extent failed')
                  ! (2,1,1,1,0)
                  @assertEqual(dataSize*12773, lb, '2 processes send gas shallow lb wrong')
                  ! (2,48,64,5,0) - (2,1,1,1,0) + 1 for extent
                  @assertEqual(dataSize*1103369, extent, '2 processes send gas shallow extent wrong')
              else
                  @assertTrue(MPI_COMM_NULL /= voltAppMpi%voltMpiComm, '2 processes volt MPI Comm wrong')
                  @assertEqual((/1/),voltAppMpi%recvCountsGasShallow, '2 processes volt countsGasShallow wrong')
                  @assertEqual((/0/),voltAppMpi%recvDisplsGasShallow, '2 processes volt displsGasShallow wrong')

                  call mpi_type_get_extent(voltAppMpi%recvTypesGasShallow(1),lb,extent,ierr)
                  @assertEqual(MPI_SUCCESS, ierr, '2 processes recv gas shallow get extent failed')
                  ! (2,1,1,1,0)
                  @assertEqual(dataSize*12773, lb, '2 processes recv gas shallow lb wrong')
                  ! (2,48,64,5,0) - (2,1,1,1,0) + 1 for extent
                  @assertEqual(dataSize*1103369, extent, '2 processes recv gas shallow extent wrong')
              endif
          CASE DEFAULT
              @assertEqual(0,1,'Unexpected number of MPI processes')
      END SELECT

  end subroutine

  @test(npes=[2,5,17])
  subroutine testMhd2VoltShallowCopy(this)
      class (MpiTestMethod), intent(inout) :: this

      integer :: i,j,k,l,m,jIndexStart,jIndexEnd
      real(rp) :: checkVal
      character(len=strLen) :: checkMessage
      real(rp) :: iVal, jVal, kVal, lVal, mVal

      ! coefficients chosen to allow easy interpretation of final values
      iVal = 1
      jVal = 20
      kVal = 400
      lVal = 8000
      mVal = 160000

      if(isGamera) then
          ! clear all cells
          gamAppMpi%State%Gas(:,:,:,:,:) = 0
          gamAppMpi%State%Bxyz(:,:,:,:) = 0

          ! set values for gas
          if(gamAppMpi%Grid%hasLowerBC(IDIR)) then
              do i=g2vCommMpi%JpSt,g2vCommMpi%JpSt+g2vCommMpi%JpSh-1
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          do l=1,NVAR
                              do m=0,gamAppMpi%Model%nSpc
                                  gamAppMpi%State%Gas(i,j,k,l,m) = &
                                      mVal*m + &
                                      lVal*l + &
                                      kVal*(k+gamAppMpi%Grid%ijkShift(KDIR)) + &
                                      jVal*(j+gamAppMpi%Grid%ijkShift(JDIR)) + &
                                      iVal*(i+gamAppMpi%Grid%ijkShift(IDIR))
                              enddo
                          enddo
                      enddo
                  enddo
              enddo

              ! set values for bxyz
              if(gamAppMpi%Grid%hasLowerBC(JDIR)) then
                  jIndexStart = gamAppMpi%Grid%jsg
              else
                  jIndexStart = gamAppMpi%Grid%js
              endif
              if(gamAppMpi%Grid%hasUpperBC(JDIR)) then
                  jIndexEnd = gamAppMpi%Grid%jeg
              else
                  jIndexEnd = gamAppMpi%Grid%je
              endif
              do i=g2vCommMpi%JpSt-1,g2vCommMpi%JpSt+g2vCommMpi%JpSh+1
                  do j=jIndexStart,jIndexEnd
                      do k=gamAppMpi%Grid%ksg,gamAppMpi%Grid%keg
                          do l=1,NDIM
                              gamAppMpi%State%Bxyz(i,j,k,l) = &
                                  lVal*l + &
                                  kVal*(k+gamAppMpi%Grid%ijkShift(KDIR)) + &
                                  jVal*(j+gamAppMpi%Grid%ijkShift(JDIR)) + &
                                  iVal*(i+gamAppMpi%Grid%ijkShift(IDIR))
                          enddo
                      enddo
                  enddo
              enddo
          endif

          ! send the data to voltron
          call sendShallowData(g2vCommMpi, gamAppMpi)
      else
          ! clear all cells
          voltAppMpi%gAppLocal%State%Gas(:,:,:,:,:) = 0

          ! receive the data from gamera
          call recvShallowData_mpi(voltAppMpi)

          ! check gas values
          do i=voltAppMpi%mhd2mix%JStart,voltAppMpi%mhd2mix%JStart+voltAppMpi%mhd2mix%JShells-1
              do j=voltAppMpi%gAppLocal%Grid%js,voltAppMpi%gAppLocal%Grid%je
                  do k=voltAppMpi%gAppLocal%Grid%ks,voltAppMpi%gAppLocal%Grid%ke
                      do l=1,NVAR
                          do m=0,voltAppMpi%gAppLocal%Model%nSpc
                              checkVal = mVal*m + &
                                  lVal*l + &
                                  iVal*i + &
                                  jVal*j + &
                                  kVal*k
                              write (checkMessage,'(A,I0,A,I0,A,I0,A,I0,A,I0,A)') 'voltron gas wrong at (',i,',',j,',',k,',',l,',',m,')'
                              @assertEqual(checkVal, voltAppMpi%gAppLocal%State%Gas(i,j,k,l,m), trim(checkMessage))
                          enddo
                      enddo
                  enddo
              enddo
          enddo

          ! check bxyz values
          do i=voltAppMpi%mhd2mix%JStart-1,voltAppMpi%mhd2mix%JStart+voltAppMpi%mhd2mix%JShells+1
              do j=voltAppMpi%gAppLocal%Grid%jsg,voltAppMpi%gAppLocal%Grid%jeg
                  do k=voltAppMpi%gAppLocal%Grid%ksg,voltAppMpi%gAppLocal%Grid%keg
                      do l=1,NDIM
                          checkVal = lVal*l + &
                              iVal*i + &
                              jVal*j + &
                              kVal*k
                          write (checkMessage,'(A,I0,A,I0,A,I0,A,I0,A)') 'voltron bxyz wrong at (',i,',',j,',',k,',',l,')'
                          @assertEqual(checkVal, voltAppMpi%gAppLocal%State%Bxyz(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
          enddo

      endif

  end subroutine testMhd2VoltShallowCopy

  !@test(npes=[2,5,17])
  subroutine testVolt2MhdShallowCopy(this)
      class (MpiTestMethod), intent(inout) :: this

      character(len=strLen) :: checkMessage

  end subroutine testVolt2MhdShallowCopy

  !@test(npes=[2,5,17])
  subroutine testShallowUpdate(this)
      class (MpiTestMethod), intent(inout) :: this

      character(len=strLen) :: checkMessage

  end subroutine testShallowUpdate

  !@test(npes=[2,5,17])
  subroutine testMhd2VoltDeepCopy(this)
      class (MpiTestMethod), intent(inout) :: this

      character(len=strLen) :: checkMessage

  end subroutine testMhd2VoltDeepCopy

  !@test(npes=[2,5,17])
  subroutine testVolt2MhdDeepCopy(this)
      class (MpiTestMethod), intent(inout) :: this

      character(len=strLen) :: checkMessage

  end subroutine testVolt2MhdDeepCopy

  !@test(npes=[2,5,17])
  subroutine testDeepUpdate(this)
      class (MpiTestMethod), intent(inout) :: this

  end subroutine testDeepUpdate


end module testVMpi

