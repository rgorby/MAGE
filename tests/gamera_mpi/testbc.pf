module testMpiBc
  use pFUnit
  use gamapp_mpi
  use usergamic

  implicit none

  type(gamAppMpi_T), allocatable :: gamAppMpi

contains

  @before
  subroutine setup(this)
      class (MpiTestMethod), intent(inout) :: this
      character(len=strLen) :: caseFile

      call setMpiReal()

      write(caseFile,'(A,I0,A)') 'blast3d_bc_', this%getNumProcesses(), '.xml'

      allocate(gamAppMpi)
      call initGamera_mpi(gamAppMpi, initUser, this%getMpiCommunicator(), caseFile, .false.)

  end subroutine setup

  @after
  subroutine teardown(this)
      class (MpiTestMethod), intent(inout) :: this

      deallocate(gamAppMpi)

  end subroutine teardown

  @test(npes=[4])
  subroutine testHaloExtBC1D(this)
      class (MpiTestMethod), intent(inout) :: this

      integer :: i,j,k,l,m,iIndex,jIndex,kIndex,minI,maxI
      real(rp) :: checkVal
      character(len=strLen) :: checkMsg
      real(rp) :: iVal, jVal, kVal, lVal, mVal

      ! coefficients chosen to allow easy interpretation of final values
      iVal = 1
      jVal = 20
      kVal = 400
      lVal = 8000
      mVal = 160000

      ! clear all cells
      gamAppMpi%State%Gas(:,:,:,:,:) = 0

      ! this case is only MPI periodic along the I axis
      ! pretend that we are setting external BC values along the J and K axes, and ensure
      !    that these are properly transmitted between adjacent ranks during halo update


      ! set values in the external BC ghost cells that this rank is responsible for
      ! by default, only ghost cells directly adjacent to physical cells
      minI = gamAppMpi%Grid%is
      maxI = gamAppMpi%Grid%ie
      if(gamAppMpi%Grid%hasLowerBC(IDIR)) then
          ! this rank has lower I BC, its external BC values must extend into those ghost cells
          minI = gamAppMpi%Grid%isg
      elseif(gamAppMpi%Grid%hasUpperBC(IDIR)) then
          ! this rank has upper I BC, its external BC values must extend into those ghost cells
          maxI = gamAppMpi%Grid%ieg
      endif

      do l=1,NVAR
          do m=0,gamAppMpi%Model%nSpc
              do i=minI,maxI
                  iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                          gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                      do k=0,gamAppMpi%Model%Ng-1
                          ! min K
                          kIndex = 1+modulo(gamAppMpi%Grid%ksg+k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                            gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          gamAppMpi%State%gas(i,j,gamAppMpi%Grid%ksg+k,l,m) = checkVal

                          ! max K
                          kIndex = 1+modulo(gamAppMpi%Grid%keg-k+gamAppMpi%Grid%ijkShift(KDIR)-1, &                                                          gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          gamAppMpi%State%gas(i,j,gamAppMpi%Grid%keg-k,l,m) = checkVal
                      enddo
                  enddo
                  do k=gamAppMpi%Grid%ksg,gamAppMpi%Grid%keg
                      kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                        gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                      do j=0,gamAppMpi%Model%Ng-1
                          ! min J
                          jIndex = 1+modulo(gamAppMpi%Grid%jsg+j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                            gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          gamAppMpi%State%gas(i,gamAppMpi%Grid%jsg+j,k,l,m) = checkVal

                          ! max J
                          jIndex = 1+modulo(gamAppMpi%Grid%jeg-j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                            gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          gamAppMpi%State%gas(i,gamAppMpi%Grid%jeg-j,k,l,m) = checkVal
                      enddo
                  enddo
              enddo
          enddo
      enddo

      ! halo update
      call haloUpdate(gamAppMpi)

      ! now check all ghost cells along j/k external BCs for correct values
      do l=1,NVAR
          do m=0,gamAppMpi%Model%nSpc
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                          gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                      do k=0,gamAppMpi%Model%Ng-1
                          ! min K
                          kIndex = 1+modulo(gamAppMpi%Grid%ksg+k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                            gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          write (checkMsg,'(I0,A,I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',gamAppMpi%Grid%ksg+k,',',l,',',m,')'
                          @assertEqual(checkVal,gamAppMpi%State%gas(i,j,gamAppMpi%Grid%ksg+k,l,m),trim(checkMsg))

                          ! max K
                          kIndex = 1+modulo(gamAppMpi%Grid%keg-k+gamAppMpi%Grid%ijkShift(KDIR)-1, &                                                          gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          write (checkMsg,'(I0,A,I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',gamAppMpi%Grid%keg-k,',',l,',',m,')'
                          @assertEqual(checkVal,gamAppMpi%State%gas(i,j,gamAppMpi%Grid%keg-k,l,m),trim(checkMsg))
                      enddo
                  enddo
                  do k=gamAppMpi%Grid%ksg,gamAppMpi%Grid%keg
                      kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                        gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                      do j=0,gamAppMpi%Model%Ng-1
                          ! min J
                          jIndex = 1+modulo(gamAppMpi%Grid%jsg+j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                            gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          write (checkMsg,'(I0,A,I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',gamAppMpi%Grid%jsg+j,',',k,',',l,',',m,')'
                          @assertEqual(checkVal,gamAppMpi%State%gas(i,gamAppMpi%Grid%jsg+j,k,l,m),trim(checkMsg))

                          ! max J
                          jIndex = 1+modulo(gamAppMpi%Grid%jeg-j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                            gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          write (checkMsg,'(I0,A,I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',gamAppMpi%Grid%jeg-j,',',k,',',l,',',m,')'
                          @assertEqual(checkVal,gamAppMpi%State%gas(i,gamAppMpi%Grid%jeg-j,k,l,m),trim(checkMsg))
                      enddo
                  enddo
              enddo
          enddo
      enddo
  end subroutine testHaloExtBC1D

  @test(npes=[16])
  subroutine testHaloExtBC2D(this)
      class (MpiTestMethod), intent(inout) :: this

      integer :: i,j,k,l,m,iIndex,jIndex,kIndex,minI,maxI,minJ,maxJ
      real(rp) :: checkVal
      character(len=strLen) :: checkMsg
      real(rp) :: iVal, jVal, kVal, lVal, mVal

      ! coefficients chosen to allow easy interpretation of final values
      iVal = 1
      jVal = 20
      kVal = 400
      lVal = 8000
      mVal = 160000

      ! clear all cells
      gamAppMpi%State%Gas(:,:,:,:,:) = 0

      ! this case is MPI periodic along the I and J axes
      ! pretend that we are setting external BC values along the K axis, and ensure
      !    that these are properly transmitted between adjacent ranks during halo update


      ! set values in the external BC ghost cells that this rank is responsible for
      ! by default, only ghost cells directly adjacent to physical cells
      minI = gamAppMpi%Grid%is
      maxI = gamAppMpi%Grid%ie
      if(gamAppMpi%Grid%hasLowerBC(IDIR)) then
          ! this rank has lower I BC, its external BC values must extend into those ghost cells
          minI = gamAppMpi%Grid%isg
      elseif(gamAppMpi%Grid%hasUpperBC(IDIR)) then
          ! this rank has upper I BC, its external BC values must extend into those ghost cells
          maxI = gamAppMpi%Grid%ieg
      endif
      minJ = gamAppMpi%Grid%js
      maxJ = gamAppMpi%Grid%je
      if(gamAppMpi%Grid%hasLowerBC(JDIR)) then
          ! this rank has lower J BC, its external BC values must extend into those ghost cells
          minJ = gamAppMpi%Grid%jsg
      elseif(gamAppMpi%Grid%hasUpperBC(JDIR)) then
          ! this rank has upper J BC, its external BC values must extend into those ghost cells
          maxJ = gamAppMpi%Grid%jeg
      endif

      do l=1,NVAR
          do m=0,gamAppMpi%Model%nSpc
              do i=minI,maxI
                  iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                  do j=minJ,maxJ
                      jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                          gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                      do k=0,gamAppMpi%Model%Ng-1
                          ! min K
                          kIndex = 1+modulo(gamAppMpi%Grid%ksg+k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                            gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          gamAppMpi%State%gas(i,j,gamAppMpi%Grid%ksg+k,l,m) = checkVal

                          ! max K
                          kIndex = 1+modulo(gamAppMpi%Grid%keg-k+gamAppMpi%Grid%ijkShift(KDIR)-1, &                                                          gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          gamAppMpi%State%gas(i,j,gamAppMpi%Grid%keg-k,l,m) = checkVal
                      enddo
                  enddo
              enddo
          enddo
      enddo

      ! halo update
      call haloUpdate(gamAppMpi)

      ! now check all ghost cells along k external BCs for correct values
      do l=1,NVAR
          do m=0,gamAppMpi%Model%nSpc
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                          gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                      do k=0,gamAppMpi%Model%Ng-1
                          ! min K
                          kIndex = 1+modulo(gamAppMpi%Grid%ksg+k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                            gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          write (checkMsg,'(I0,A,I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',gamAppMpi%Grid%ksg+k,',',l,',',m,')'
                          @assertEqual(checkVal,gamAppMpi%State%gas(i,j,gamAppMpi%Grid%ksg+k,l,m),trim(checkMsg))

                          ! max K
                          kIndex = 1+modulo(gamAppMpi%Grid%keg-k+gamAppMpi%Grid%ijkShift(KDIR)-1, &                                                          gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = mVal*m + lVal*l + iVal*iIndex + jVal*jIndex + kVal*kIndex
                          write (checkMsg,'(I0,A,I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',gamAppMpi%Grid%keg-k,',',l,',',m,')'
                          @assertEqual(checkVal,gamAppMpi%State%gas(i,j,gamAppMpi%Grid%keg-k,l,m),trim(checkMsg))
                      enddo
                  enddo
              enddo
          enddo
      enddo
  end subroutine testHaloExtBC2D

end module testMpiBc

