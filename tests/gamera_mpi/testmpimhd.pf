module testMpiMhd
  use pFUnit
  use gamapp_mpi
  use usergamic

  implicit none

  type(gamAppMpi_T), allocatable :: gamAppMpi

contains

  @before
  subroutine setup(this)
      class (MpiTestMethod), intent(inout) :: this
      character(len=strLen) :: caseFile

      call setMpiReal()

      write(caseFile,'(A,I0,A)') 'blast3d_mhd_', this%getNumProcesses(), '.xml'

      allocate(gamAppMpi)
      call initGamera_mpi(gamAppMpi, initUser, this%getMpiCommunicator(), caseFile, .false.)

  end subroutine setup

  @after
  subroutine teardown(this)
      class (MpiTestMethod), intent(inout) :: this

      deallocate(gamAppMpi)

  end subroutine teardown

  @test(npes=[1,4,16,64])
  subroutine testHaloUpdateBxyz(this)
      class (MpiTestMethod), intent(inout) :: this

      integer :: i,j,k,l,iIndex,jIndex,kIndex
      real(rp) :: checkVal
      character(len=strLen) :: checkMessage
      real(rp) :: iVal, jVal, kVal, lVal

      ! coefficients chosen to allow easy interpretation of final values
      iVal = 1
      jVal = 20
      kVal = 400
      lVal = 8000

      ! clear all cells
      gamAppMpi%State%Bxyz(:,:,:,:) = 0

      ! set values in physical cells only
      do i=gamAppMpi%Grid%is,gamAppMpi%Grid%ie
          do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
              do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                  do l=1,NDIM
                      gamAppMpi%State%Bxyz(i,j,k,l) = &
                          lVal*l + &
                          kVal*(k+gamAppMpi%Grid%ijkShift(KDIR)) + &
                          jVal*(j+gamAppMpi%Grid%ijkShift(JDIR)) + &
                          iVal*(i+gamAppMpi%Grid%ijkShift(IDIR))
                  enddo
              enddo
          enddo
      enddo

      ! halo update
      call haloUpdate(gamAppMpi)

      ! check values in all updated cells
      SELECT CASE(this%getNumProcesses())
          CASE (1)
              ! degenerate MPI case doesn't update any ghost cells, only check physical for no modifications
              do i=gamAppMpi%Grid%is,gamAppMpi%Grid%ie
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          do l=1,NDIM
                              iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                           gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                              jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                           gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                              kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                           gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                              checkVal = lVal*l + &
                                  iVal*iIndex + &
                                  jVal*jIndex + &
                                  kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%Bxyz(i,j,k,l), trim(checkMessage))
                          enddo
                      enddo
                  enddo
              enddo
          CASE (4)
              ! decomposed in I, check I ghosts
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          do l=1,NDIM
                              iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                           gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                              jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                           gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                              kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                           gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                              checkVal = lVal*l + &
                                  iVal*iIndex + &
                                  jVal*jIndex + &
                                  kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%Bxyz(i,j,k,l), trim(checkMessage))
                          enddo
                      enddo
                  enddo
              enddo
          CASE (16)
              ! decomposed in I and J, check ghosts in both dimensions
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          do l=1,NDIM
                              iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                           gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                              jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                           gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                              kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                           gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                              checkVal = lVal*l + &
                                  iVal*iIndex + &
                                  jVal*jIndex + &
                                  kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%Bxyz(i,j,k,l), trim(checkMessage))
                          enddo
                      enddo
                  enddo
              enddo
          CASE (64)
              ! fully decomposed, check all ghost cells for all ranks
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      do k=gamAppMpi%Grid%ksg,gamAppMpi%Grid%keg
                          do l=1,NDIM
                              iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                           gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                              jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                           gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                              kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                           gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                              checkVal = lVal*l + &
                                  iVal*iIndex + &
                                  jVal*jIndex + &
                                  kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%Bxyz(i,j,k,l), trim(checkMessage))
                          enddo
                      enddo
                  enddo
              enddo
          CASE DEFAULT
              @assertEqual(0,1,'Unexpected number of processes')
      ENDSELECT

  end subroutine testHaloUpdateBxyz

  @test(npes=[1,4,16,64])
  subroutine testHaloUpdateMagFlux(this)
      class (MpiTestMethod), intent(inout) :: this

      integer :: i,j,k,l,iIndex,jIndex,kIndex
      real(rp) :: checkVal
      character(len=strLen) :: checkMessage
      real(rp) :: iVal, jVal, kVal, lVal

      ! coefficients chosen to allow easy interpretation of final values
      iVal = 1
      jVal = 20
      kVal = 400
      lVal = 8000

      ! clear all cells
      gamAppMpi%State%magFlux(:,:,:,:) = 0

      ! set values in physical faces only
      ! because the case is triply periodic is=ie+1, and the same for j and k
      l=IDIR
      do i=gamAppMpi%Grid%is,gamAppMpi%Grid%ie+1
          do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
              do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                  iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                           gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                  jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                           gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                  kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                           gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                  gamAppMpi%State%magFlux(i,j,k,l) = &
                      lVal*l + &
                      kVal*(kIndex) + &
                      jVal*(jIndex) + &
                      iVal*(iIndex)
              enddo
          enddo
      enddo
      l=JDIR
      do i=gamAppMpi%Grid%is,gamAppMpi%Grid%ie
          do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je+1
              do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                  iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                           gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                  jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                           gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                  kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                           gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                  gamAppMpi%State%magFlux(i,j,k,l) = &
                      lVal*l + &
                      kVal*(kIndex) + &
                      jVal*(jIndex) + &
                      iVal*(iIndex)
              enddo
          enddo
      enddo
      l=KDIR
      do i=gamAppMpi%Grid%is,gamAppMpi%Grid%ie
          do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
              do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke+1
                  iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                           gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                  jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                           gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                  kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                           gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                  gamAppMpi%State%magFlux(i,j,k,l) = &
                      lVal*l + &
                      kVal*(kIndex) + &
                      jVal*(jIndex) + &
                      iVal*(iIndex)
              enddo
          enddo
      enddo

      ! halo update
      call haloUpdate(gamAppMpi)

      ! check values in all updated cells
      SELECT CASE(this%getNumProcesses())
          CASE (1)
              ! degenerate MPI case doesn't update any ghost cells, only check physical for no modifications
              l=IDIR
              do i=gamAppMpi%Grid%is,gamAppMpi%Grid%ie+1
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
              l=JDIR
              do i=gamAppMpi%Grid%is,gamAppMpi%Grid%ie
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je+1
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
              l=KDIR
              do i=gamAppMpi%Grid%is,gamAppMpi%Grid%ie
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke+1
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
          CASE (4)
              ! also check I-dimension ghosts
              l=IDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg+1
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
              l=JDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je+1
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
              l=KDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%js,gamAppMpi%Grid%je
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke+1
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
          CASE (16)
              ! also check I and J dimension ghosts
              l=IDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg+1
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
              l=JDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg+1
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
              l=KDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      do k=gamAppMpi%Grid%ks,gamAppMpi%Grid%ke+1
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
          CASE (64)
              ! check all ghosts
              l=IDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg+1
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      do k=gamAppMpi%Grid%ksg,gamAppMpi%Grid%keg
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
              l=JDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg+1
                      do k=gamAppMpi%Grid%ksg,gamAppMpi%Grid%keg
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
              l=KDIR
              do i=gamAppMpi%Grid%isg,gamAppMpi%Grid%ieg
                  do j=gamAppMpi%Grid%jsg,gamAppMpi%Grid%jeg
                      do k=gamAppMpi%Grid%ksg,gamAppMpi%Grid%keg+1
                          iIndex = 1+modulo(i+gamAppMpi%Grid%ijkShift(IDIR)-1, &
                                   gamAppMpi%Grid%Nip*gamAppMpi%Grid%NumRi)
                          jIndex = 1+modulo(j+gamAppMpi%Grid%ijkShift(JDIR)-1, &
                                   gamAppMpi%Grid%Njp*gamAppMpi%Grid%NumRj)
                          kIndex = 1+modulo(k+gamAppMpi%Grid%ijkShift(KDIR)-1, &
                                   gamAppMpi%Grid%Nkp*gamAppMpi%Grid%NumRk)
                          checkVal = lVal*l + &
                              iVal*iIndex + &
                              jVal*jIndex + &
                              kVal*kIndex
                              write (checkMessage,'(I0,A,I0,A,I0,A,I0,A,I0,A)') this%getNumProcesses(),' processor wrong at (',i,',',j,',',k,',',l,')'
                              @assertEqual(checkVal, gamAppMpi%State%magFlux(i,j,k,l), trim(checkMessage))
                      enddo
                  enddo
              enddo
          CASE DEFAULT
              @assertEqual(0,1,'Unexpected number of processes')
      ENDSELECT

  end subroutine testHaloUpdateMagFlux

end module testMpiMhd

