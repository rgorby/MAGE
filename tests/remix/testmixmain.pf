module testmixmain
  use pfUnit
  use mixmain
  use mixapp
  use voltapp
  use gamapp

  implicit none

  character(len=strLen) :: kaijuHome

contains

  @before
  subroutine firstSerial()
  end subroutine firstSerial

  @after
  subroutine lastSerial()
  end subroutine lastSerial

  !@test
  subroutine testZeroInput()
    ! testing that an input of all zeroes gets output of all zeroes
    type(mixApp_T) :: remixApp
    type(gamApp_T) :: gameraApp
    character(len=strLen) :: caseInput = 'cmiD.xml'

    write(*,*) 'Doing testZeroInput ...'
    call initGamera(gameraApp, caseInput)

    call initializeRemixFromGamera(remixApp, gameraApp, caseInput)

    call convertGameraToRemix(gameraApp, remixApp)

    call mhd2mix(remixApp)

    ! field aligned current in remixApp%ion(h)%St%Vars(:,:,FAC)
    remixApp%ion(NORTH)%St%Vars(:,:,FAC) = 0
    remixApp%ion(SOUTH)%St%Vars(:,:,FAC) = 0

    call run_mix(remixApp%ion, remixApp%tilt, remixApp%conductance)

    ! potential in remixApp%ion(h)%St%Vars(:,:,POT)
    ! error value allows 1e-3 error per cell on average
    @assertLessThanOrEqual(sum(abs(remixApp%ion(NORTH)%S%Solution)), 8.1_rp, 'Non-zero remix output in North hemisphere')
    @assertLessThanOrEqual(sum(abs(remixApp%ion(SOUTH)%S%Solution)), 8.1_rp, 'Non-zero remix output in South hemisphere')

  end subroutine testZeroInput

  @test
  subroutine testConstantSolution()
    ! testing that an input of all zeroes gets output of all zeroes
    type(mixApp_T) :: remixApp
    type(gamApp_T) :: gameraApp

    real(rp) :: testValue = 240.19
    character(len=strLen) :: caseInput = 'cmiD.xml'

    write(*,*) 'Doing testConstantSolution ...'
    call initGamera(gameraApp, caseInput)

    call initializeRemixFromGamera(remixApp, gameraApp, caseInput)

    call convertGameraToRemix(gameraApp, remixApp)

    call mhd2mix(remixApp)

    ! field aligned current in remixApp%ion(h)%St%Vars(:,:,FAC)
    remixApp%ion(NORTH)%St%Vars(:,:,FAC) = 0
    remixApp%ion(SOUTH)%St%Vars(:,:,FAC) = 0

    ! modify low lat boundary condition for test
    remixApp%ion(NORTH)%P%llbc_value = testValue
    remixApp%ion(SOUTH)%P%llbc_value = testValue

    call run_mix(remixApp%ion, remixApp%tilt, remixApp%conductance)

    ! potential in remixApp%ion(h)%St%Vars(:,:,POT)
    ! error value allows 1e-3 error per cell on average
    @assertLessThanOrEqual(sum(abs(remixApp%ion(NORTH)%S%Solution - testValue)), 8.1_rp, 'Remix output in North hemisphere not specified value')
    @assertLessThanOrEqual(sum(abs(remixApp%ion(SOUTH)%S%Solution - testValue)), 8.1_rp, 'Remix output in South hemisphere not specified value')

  end subroutine testConstantSolution

  !@test
  subroutine testAzimuthallyDependentFAC()
    ! testing that an input of all zeroes gets output of all zeroes
    type(mixApp_T) :: remixApp
    type(gamApp_T) :: gameraApp

    character(len=strLen) :: caseInput = 'cmiD.xml'
    integer :: h,ip,it
    real(rp) :: thetaMin, thetaDelta

    write(*,*) 'Doing testAzimuthallyDependentFAC ...'
    call initGamera(gameraApp, caseInput)

    call initializeRemixFromGamera(remixApp, gameraApp, caseInput)

    call convertGameraToRemix(gameraApp, remixApp)

    call mhd2mix(remixApp)

    ! field aligned current in remixApp%ion(h)%St%Vars(:,:,FAC)
    thetaMin = 22.0_rp
    thetaDelta = 12.0_rp
    do h=1,size(remixApp%ion)
        do ip=1,remixApp%ion(h)%G%Np
            do it=1,remixApp%ion(h)%G%Nt
                if(remixApp%ion(h)%G%t(ip,it) .ge. thetaMin .and. remixApp%ion(h)%G%t(ip,it) .le. (thetaMin+thetaDelta)) then
                    remixApp%ion(h)%St%Vars(ip,it,FAC) = sin(remixApp%ion(h)%G%t(ip,it)) * sin(remixApp%ion(h)%G%p(ip,it))
                else
                    remixApp%ion(h)%St%Vars(ip,it,FAC) = 0.0_rp
                endif
            end do
        end do
    end do

    call run_mix(remixApp%ion, remixApp%tilt, remixApp%conductance)

    ! potential in remixApp%ion(h)%St%Vars(:,:,POT)

  end subroutine testAzimuthallyDependentFAC

end module testmixmain
